group Greedy;

staticHeader() ::= <<
public static final int LEFT = 1;
public static final int RIGHT = 2;
static java.util.Map\<String, Integer\> tokenLiteralMap = new java.util.HashMap\<String, Integer\>();
static {
	for (int i = 0; i \< tokenNames.length; i++)
		tokenLiteralMap.put(tokenNames[i], i);
}
static int lookupTokenFromGrammarString(String token) {
	return tokenLiteralMap.get(token);
}
>>

header(name, precedences) ::= <<

static int[] <name>_prec = new int[tokenNames.length];
static int[] <name>_uprec = new int[tokenNames.length];
static int[] <name>_postprec = new int[tokenNames.length];
static int[] <name>_assoc = new int[tokenNames.length];
static {
	<precedences:prec(precl=it,level=i,name=name)>
}
int <name>_nextp(int p) {
   int prevOpType = input.LA(-1);
   if ( <name>_assoc[prevOpType]==LEFT ) return <name>_prec[prevOpType]+1;
   else return <name>_prec[prevOpType];
}
>>

prec(precl,level,name) ::= <<

<precl:{p|
    <if(p.binary)>
		<name>_prec[lookupTokenFromGrammarString("<p.tokenText>")] = <level>;
    <endif>
    <if(p.unary)>
		<name>_uprec[lookupTokenFromGrammarString("<p.tokenText>")] = <level>;
    <endif>
    <if(p.rightAssoc)>
		<name>_assoc[lookupTokenFromGrammarString("<p.tokenText>")] = RIGHT;
    <else>
		<name>_assoc[lookupTokenFromGrammarString("<p.tokenText>")] = LEFT;
	<endif>
}>
>>




exprRule(name,terminals,bops,uops,tops,buildTree) ::= <<

<name> : <name>_expr[0] ;
<name>_expr[int p]
   :   <name>_terminals
       ( options {backtrack=false;}: //to prevent our predicate from being hoisted
		{<name>_prec[input.LA(1)]>=p}?=> (<bops;separator="|">)<if(buildTree)>^<endif> <name>_expr[<name>_nextp(p)]

       )*
   <if(uops)>|   <if(rest(uops))>(<uops;separator="|">)<else><uops><endif><if(buildTree)>^<endif> {int q=<name>_uprec[input.LA(-1)];} <name>_expr[q]<endif>
   /*<if(tops)>|	<name>_terminals<endif>*/
   ;
<name>_terminals
   :	<terminals;separator="|">;

>>