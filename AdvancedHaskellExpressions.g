grammar HaskellExpressions;

options { output=AST; ASTLabelType=CommonTree; }
tokens { PREINC; POSTINC; CALL; INDEX; }

@members {
public static final int LEFT = 1;
public static final int RIGHT = 2;
static int[] prec = new int[tokenNames.length];
static int[] uprec = new int[tokenNames.length];
static int[] postprec = new int[tokenNames.length];
static int[] assoc = new int[tokenNames.length];
static {
   for (int i=0; i<tokenNames.length; i++) { assoc[i]=LEFT; }
   prec[CASH] = 0;
   prec[CASHBANG] = 0;
   prec[BINDD] = 1;
   prec[BIND] = 1;
   prec[OR] = 2;
   prec[AND] = 3;
   prec[EQ] = 4;
   prec[NEQ] = 4;
   prec[LT] = 4;
   prec[LTE] = 4;
   prec[GT] = 4;
   prec[GTE] = 4;
   prec[CONS] = 5;
   prec[PLUS] = 6;
   prec[MINUS] = 6;
   prec[TIMES] = 7;
   prec[DIV] = 7;
   prec[HAT] = 8;
   prec[TWOHAT] = 8;
   prec[EXP] = 8;
   prec[DOT] = 9;
   
   assoc[OR] = RIGHT;
   assoc[AND] = RIGHT;
   assoc[CONS] = RIGHT;
   assoc[HAT] = RIGHT;
   assoc[TWOHAT] = RIGHT;
   assoc[EXP] = RIGHT;
   assoc[DOT] = RIGHT;

   uprec[MINUS] = 7;       // sits between +/- binary and * binary ops
//   postprec[LPAREN] = 5;   // lower than DOT for p.f()
//   postprec[LBRACK] = 5;
//   postprec[INC] = 5;
}


int nextp(int p) {
   int prevOpType = input.LA(-1);
   if ( assoc[prevOpType]==LEFT ) return prec[prevOpType]+1;
   else return prec[prevOpType];
}
}

expressions : expression ('\n' expression)+ EOF;

expression : e[0] ;

ex[int k] : e[k];
/** This could be autogenerated if you give me primary and suffix and precedence levels */
e[int p]
   :   (sExpr->sExpr)
       (   {prec[input.LA(1)]>=p}?=>     bop r=ex[nextp(p)] -> ^(bop $e $r)
//       |   {postprec[input.LA(1)]>=p}?=> suffix[$e.tree]   -> {$suffix.tree}
       )*
   ;

sExpr
   :   NUMBER
   |   ID
   |   BOOL
   |   uop^ {int q=uprec[input.LA(-1)];} e[q]
   |   '(' expression ')' -> expression
   ;

NUMBER	:	('0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9')+;
BOOL    :   'True' | 'False';
ID      :   'f'|'g'|'h';

//suffix[CommonTree lhs]
//   :   t='[' expr ']'                -> ^(INDEX[$t] {$lhs} expr)
//   |   t='(' (expr (',' expr)*)? ')' -> ^(CALL[$t] {$lhs} expr*)
//   |   t='++'                        -> ^(POSTINC[$t] {$lhs})
//   ;

bop :   '$' | '$!' | '>>' | '>>=' | '||' 
    |   '&&' | '==' | '/=' | '<' | '<='  
    |   '>=' | '>' | ':' | '+' | '-' | '*' 
    |   '/' | '^' | '^^' | '**' | '.' ;

uop :   '-';

CASH : '$';
CASHBANG : '$!';
BINDD : '>>';
BIND : '>>=';
OR:'||';
AND:'&&';
EQ:'==';
NEQ:'/=';
LT:'<';
LTE:'<=';
GTE:'>=';
GT:'>';
CONS:':';
PLUS:'+';
MINUS:'-';
TIMES:'*';
DIV:'/';
HAT:'^';
TWOHAT:'^^';
EXP:'**';
DOT:'.';

WS  : (' '|'\n')+ ;
